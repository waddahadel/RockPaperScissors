# vim:sw=2 syntax=asm
.data
    
.text
  .globl gen_byte, gen_bit

# Arguments:
#     $a0 : address of configuration in memory
#   0($a0): eca       (1 word)
#   4($a0): tape      (1 word)
#   8($a0): tape_len  (1 byte)
#   9($a0): rule      (1 byte)
#  10($a0): skip      (1 byte)
#  11($a0): column    (1 byte)
#
# Return value:
#  Compute the next valid byte (00, 01, 10) and put into $v0
#  If 11 would be returned, produce two new bits until valid
#


gen_byte:
    # initialize the stack pointer and check the first generated bit
   
    addi $sp , $sp , -4
    sw $ra , 0($sp)
    jal gen_bit
    move $t1 , $v0
 	
 	# get the second bit
    jal gen_bit
    move $t2 , $v0
    # do the magic
    and $t3 , $t1 ,$t2
    bnez $t3, gen_byte
    sll $v0 , $t1 ,1
    or $v0 , $v0, $t2
    lw $ra , 0($sp)
    addi $sp, $sp , 4
     
       
    jr $ra            # Return the generated byte



# Arguments:
#     $a0 : address of configuration in memory
#   0($a0): eca       (1 word)
#   4($a0): tape      (1 word)
#   8($a0): tape_len  (1 byte)
#   9($a0): rule      (1 byte)
#  10($a0): skip      (1 byte)
#  11($a0): column    (1 byte)
#
# Return value:
#  Look at the field {eca} and use the associated random number generator to generate one bit.
#  Put the computed bit into $v0

gen_bit:

    # loud our necessary values..
    
    
#initialize the stack to keep us safe
    addi $sp , $sp , -16
    sw $a0 , 0($sp)
    sw $ra , 4($sp)
    sw $s0 , 8($sp)
    sw $s6 , 12($sp)
     # loud our necessary values..
     lw $s7 , 0($a0) # the eca
     lb $s0 , 10($a0) # number of simulations (skip..)
     lb $t3 , 11($a0) # this is just our column..
     lb $t4 , 8($a0) # this is our tape's length
    
     subi $t4 , $t4 ,1 # for convenience with the indexing..
     subu $s6 , $t4 ,$t3  # this is how much shift we need to obtain our bit.. 
     
     bnez $s7 , simulate
#setting the seed
    
    lw $a1 , 4($a0)
    li $v0 , 40
    syscall
    
#generation of the random number
  
    li $a0, 0           
    li $v0, 41          
    syscall
    andi $v0 , $a0 , 1
    
    j terminate
    
    simulate: 
          beqz $s0, extract_the_bit
          subi $s0, $s0 ,1
          jal  simulate_automaton # simulate the thing.
          j simulate
           
           
  
           
             
     extract_the_bit:
          lw $t1 , 4($a0) # load the new tape
          srlv $t1 , $t1  $s6
          andi $v0 , $t1 , 1
    
    
    
terminate:
    # release the stack and end things.
    lw $a0, 0($sp)
    lw $ra , 4($sp)
    lw $s0 , 8($sp)
    lw $s6 , 12($sp)
    addi $sp, $sp , 16
    jr $ra    
    
# I will ad a whole new routine to keep the work tree clean.


  
 	
 	
