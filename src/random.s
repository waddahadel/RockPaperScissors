# vim:sw=2 syntax=asm
.data
    
.text
  .globl gen_byte, gen_bit

# Arguments:
#     $a0 : address of configuration in memory
#   0($a0): eca       (1 word)
#   4($a0): tape      (1 word)
#   8($a0): tape_len  (1 byte)
#   9($a0): rule      (1 byte)
#  10($a0): skip      (1 byte)
#  11($a0): column    (1 byte)
#
# Return value:
#  Compute the next valid byte (00, 01, 10) and put into $v0
#  If 11 would be returned, produce two new bits until valid
#


gen_byte:
    # initialize the stack pointer and check the first generated bit
   
    addi $sp , $sp , -4
    sw $ra , 0($sp)
    
    
    
    jal gen_bit
    move $a3 , $v0
    
    # get the second bit
    jal gen_bit
    move $t2 , $v0
    # do the magic
    and $t3 , $a3 ,$t2
    bnez $t3, gen_byte
    sll $v0 , $a3 ,1
    or $v0 , $v0, $t2
    
    lw $ra , 0($sp)

    addi $sp, $sp , 4
     
       
    jr $ra            # Return the generated byte



# Arguments:
#     $a0 : address of configuration in memory
#   0($a0): eca       (1 word)
#   4($a0): tape      (1 word)
#   8($a0): tape_len  (1 byte)
#   9($a0): rule      (1 byte)
#  10($a0): skip      (1 byte)
#  11($a0): column    (1 byte)
#
# Return value:
#  Look at the field {eca} and use the associated random number generator to generate one bit.
#  Put the computed bit into $v0

gen_bit:

    # loud our necessary values..
    
    
#initialize the stack to keep us safe
    addi $sp , $sp , -8
    sw $a0 , 0($sp)
    sw $ra , 4($sp)
    
   
 
           # loud our necessary values..
     lw $t5 , 0($a0) # the eca
     lb $s1 , 10($a0) # number of simulations (skip..)
     lb $t3 , 11($a0) # this is just our column..
     lb $t4 , 8($a0) # this is our tape's length
    
     subi $t4 , $t4 ,1 # for convenience with the indexing..
     subu $s6 , $t4 ,$t3  # this is how much shift we need to obtain our bit.. 
     
     bnez $t5 , simulate
#setting the seed
    
    lw $a1 , 4($a0)
    li $v0 , 40
    syscall
    
#generation of the random number
  
    li $a0, 0           
    li $v0, 41          
    syscall
    andi $v0 , $a0 , 1
    
    j terminate
    
    simulate: 
          beqz $s1, extract_the_bit
          subi $s1, $s1 ,1
          jal  simulate_automaton # simulate the thing.
          j simulate
           
           
  
           
             
     extract_the_bit:
          lw $t1 , 4($a0) # load the new tape
          srlv $t1 , $t1  ,$s6
          andi $t1 , $t1 , 1
          move $v0 , $t1
          move $t1 , $zero 
          
    
    
terminate:
    # release the stack and end things.
    lw $a0, 0($sp)
    lw $ra , 4($sp)
    
    
    addi $sp, $sp , 8
    jr $ra    
    


  
 	
 	
